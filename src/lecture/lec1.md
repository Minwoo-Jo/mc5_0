# 재귀, 부동점결합자

1부터 n까지의 합을 구하는 함수를 작성한다고 합시다. 다른 언어들의 경우에는 다음과 같은 방법을 생각해볼 수 있을 것입니다. (아래는 LFLC와 비슷한 의사 코드입니다.)

반복문을 사용할 경우,

```lflc
sum := \n.         # sum을 인수 n을 받는 함수로 정의
  val := 0;        # 합을 저장할 변수를 만듦
  for 1 n (\i.     # 1부터 n까지 값을 i에 넣고 반복
    val = val + i) # val에 i를 계속 더함
  val;             # val을 반환
```

재귀호출을 사용할 경우,

```lflc
sum := λn.          # sum을 인수 n을 받는 함수로 정의
 if (n == 0)
   0                # n == 0이면 합이 0
   (n + sum (n - 1)); # n != 0이면 n과 sum (n - 1)를 더함
```

하지만 아쉽게도 LFLC에서는 이 두가지 모두 다 작성이 불가능합니다. 우선 첫번째로 반복문이 없고, 두번째로는 재귀호출이 없기 때문입니다. 아래의 경우 sum을 정의한 람다 내에 sum이 있습니다. 하지만, LFLC에서는 위와 같은 코드는 다음과 같이 바뀝니다.

```lflc
(λn. if (n == 0) 0 (n + sum (n - 1))) =: λsum.
  ...
```

즉, `λsum. ...`이라는 함수 **밖에서** sum을 호출하려고 하고 있는 것이죠. `=:` 좌변에서는 sum에 관한 그 어떤 정보도 없기 때문에 이 코드는 `sum`이 바인딩 되지 않았다고 나오면서 컴파일 에러가 나옵니다.

하지만 결합자(combinator)의 힘을 빌리면 재귀호출이 불가능하지는 않습니다.

## 재귀호출의 구현

만약 자기 자신을 인수로 받아오면 어떨까요? 어차피 sum이라는 함수를 호출하는 시점에서는 sum이 어떤 것인지 알고 있으므로, sum에 sum 자기 자신과 인수 n을 넣는 것이죠.

```lflc
sum := λf.λn.  # f에 자기 자신이 들어감
  if (n == 0)
    0
    (n + f (n - 1));
sum sum 10
```

이렇게 하면 될까요? 아쉽게도 문제가 하나 있습니다. 위 코드에서는 f에 sum을 넣는데, sum은 sum 자기 자신을 받습니다. 즉 sum 내에서 f를 호출할 때에 자기 자신을 다시 넣어주어야 합니다. 즉, 아래처럼 되어야합니다.

```lflc
sum := λf.λn.  # f에 자기 자신이 들어가
  if (n == 0)
    0
    (n + f f (n - 1)); # f에 자기 자신(f)를 다시 넣어줌
sum sum 10
```

저 `f f`나 `sum sum` 등을 조금 간단하게 쓸 수 있도록 해주는 것이 U 결합자입니다. U 결합자는 `λf. f f`로 정의됩니다. 이것을 사용하면 위를 다음과 같이 쓸 수 있습니다.

```lflc
sum := U λf.λn.
  if (n == 0)
    0
    (n + (U f) (n - 1));
sum 10
```

하지만 이 역시 재귀함수 내부에서 U를 써줘야합니다. 저 U를 없애버릴 방법이 없을까요?

## 부동점결합자

부동점(Fixed-point)은 수학에서 어떤 함수 `f`에 대해 `f(x) = x`를 만족하는 `x`를 가리키는 말입니다. 그런데 재귀호출 얘기를 하다말고 부동점이 왜 나왔을까요?

저희가 지금 하고싶은 것은 코드를 다음과 같이 쓰는 것입니다.

```lflc
sum := ??? λf.λn.  #???에는 어떤 연산이 들어감
  if (n == 0)
    0
    (n + f (n - 1));
sum 10
```

이렇게 U 대신 `???`이라는 것을 추가해서 함수 내부에서 `(U f)`처럼 `f`에 `f`를 넣어주지 않고 바로 `f`처럼 쓰는 것이죠.

그런데 이미 알고 있지만 이렇게 하려면 sum의 인수 f에 숫자만 받는 재귀함수를 넣으면 됩니다. 이게 뭘까요? 바로 sum의 인수 f에 숫자만 받는 재귀함수를 넣은 것입니다. 그게 뭐냐고요? 바로 sum의 인수 f에 숫자만 받는 재귀함수를 넣은 것입니다. 계속 같은 말을 하고 있지만 이게 답입니다. 코드로 적자면 `sum (sum (sum (sum ...)))`처럼 되겠네요. 저렇게 무한히 `sum`을 넣어주어야 합니다.

여기서 `???`는 `sum`을 받아서 `sum (sum (sum (sum ...)))`를 만들어주는 무언가여야 합니다. 즉, `λ??? := λf. f (f (f ...))`처럼 정의가 되겠네요. 하지만 이걸 진짜로 코드로 적기에는 너무 무한합니다. 그래서 대신 부동점을 생각해볼 것입니다.

어떤 `Y`가 있고, 이 `Y`에 어떤 함수 `f`를 넣으면 그게 `f`의 부동점이 된다고 정의합시다. 즉, `Y f = f (Y f)`처럼 되어야하는 것입니다. 즉, `Y f`는 `f (Y f)`이고, `Y f`의 정의에 따라 `f (f (Y f))`와도 같습니다. 이런 식으로 무한히 `Y f`를 `f (Y f)`로 바꿀 수 있고, 그 결과는 `f (f (f ...))`가 될 것입니다. 우리가 원하던 위의 `sum (sum (sum (sum ...)))`과 같죠.

저 Y를 LFLC로 적어보면 `λY := λf. f (Y f);`가 될 것입니다. 하지만 여기에도 문제가 하나 있는데, Y에 들어가는 함수에서 Y를 사용한다는 것이죠. 하지만 이는 `U`를 사용해서 구현할 수 있습니다. `λY := U λY.λf. f (Y Y f);` 이렇게 말이죠. 여기서 이 `Y`를 부동점결합자(Fixed-point Combinator)라고 부릅니다.

이 `Y` 자체는 LFLC나 Haskell 등에서는 잘 동작하지만, 다른 언어에서 같은 정의를 사용할 경우에는 무한루프를 발생시킵니다. 왜냐하면 `f (Y Y f)`에서 `f`라는 함수에 `(Y Y f)`의 결과를 넣기 위해 `(Y Y f)`를 호출하는데, 결과가 나오려면 다시 `f (Y Y f)`를 평가해야하기 때문입니다. LFLC나 Haskell은 게으른 연산을 사용하기 때문에 `(Y Y f)` 를 함수로 하여 호출을 하기 전까지는 계산을 지연시키지만, 다른 언어는 그렇지 않기 때문입니다. 이 때문에 저 부분을 인수를 받는 함수로 감싸주어야합니다. 즉, `λY := U λY.λf.λa. f (Y Y f) a;`처럼 해야합니다. (이는 η-reduction을 반대로 한 것입니다.)
