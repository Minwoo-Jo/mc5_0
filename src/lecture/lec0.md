# 람다 대수, LFLC

## 람다 대수

람다 대수는 알론조 처치가 제안했던 논리적 형식 체계입니다. 문법도 매우 단순해서 다음과 같은 것밖에 없습니다.

* `x` 와 같은 변수
* `λx.M` 처럼 M이라는 표현식을 x라는 종속 변수로 추상화한 함수1
* `M N` 처럼 M이라는 함수에 N을 적용

이렇게 문법이 단순하지만 이것만으로 이 체계는 튜링 완전합니다. 또한 람다 대수에 영향을 받아 지금의 함수형 언어가 나오게 되었죠. 여기서는 LCLF라는 람다 대수에 약간의 설탕을 친 언어를 사용하여 람다를 사용해보도록 하겠습니다.

## LFLC?

LFLC는 lumiknit flavored lambda calculus의 약자로, 그냥 제가 약간의 문법적 설탕을 친, 람다 대수와 거의 비슷한 프로그래밍 언어입니다. 연습용으로 만든 언어이기 때문에 매우 작고 간단하고 느린 언어이지만, 람다 대수에서 가능한 것은 대부분 할 수 있을 것입니다.

LFLC는 다음과 같은 문법을 가지고 있습니다.

* `#`으로 시작할 경우 해당 줄의 끝까지 주석(실행시 무시됨)
* `123`, `+42`, `-273` 등의 정수
* `"Hello"`, `"문자열"` 처럼 큰 따옴표로 감쌀 경우 문자열
* `x`, `y`, `value`, `function` 처럼 알파벳, 숫자, '_' 등으로 이루어진 변수
* `@print`, `@subr`, `@if` 처럼 @로 시작해서 알파벳, 숫자, '_'등으로 이루어진 내장 함수
* `+`, `*`, `**`, `!=` 등의 연산자
* `function value`처럼 두 식을 공백을 두고 연달아 적을 경우에 함수 적용
* `first + second`처럼 두 식을 연산자를 두고 연달아 적을 경우에 연산자 적용
* `\x.x`, `λa. λb. a + b`처럼 '\\'나 'λ' 뒤에 매개변수명과 '.', 표현식이 나오게 되면 함수
* `\x <- y; z`처럼 '\\'나 'λ' 뒤에 매개변수명과 연산자, 표현식, ';', 표현식 순으로 나오게 되면 연산자 적용 함수

이 중 주의해야 할 문법 일부에 대해서 설명을 따로 해보겠습니다.

### 이름

람다 대수는 원래 프로그래밍 언어가 아닌 수학에서 사용되던 형식 체계이다보니, 기호도 수학에서 사용되는 것과 같습니다. 그래서 변수명도 'x', 'Y' 처럼 한 글자로만 사용합니다. 하지만 LFLC는 변수명을 한 글자로만 하는 것을 원치 않기 때문에 공백 없이 붙여써진 '단어' 단위로 이름을 받습니다.

그래서 람다 대수에서 'λa.λb.M'를 'λab.M' 처럼 람다 하나로 줄여서 쓰기도 하는데, 여기서는 저 둘이 완전히 다른 의미를 가집니다.

### 커링

LFLC에는 다변수함수라는 것이 없습니다. `λx y. x + y` 처럼 2개 이상의 값을 받는 람다는 쓸 수 없다는 것입니다. 대신 커링을 하여 람다 안에 람다를 넣어서 이와 비슷한 기능을 구현할 수 있습니다. 예를 들어 위 같은 경우는 `λx. (λy. x + y)` 처럼 쓰는 것이죠. 이후 호출할 때에는 인수를 공백으로 구분하여 계속 나열하면 됩니다. 예를 들어서 `λx. (λy. x + y)`를 `f`라고 하면 `(f 3) 4`처럼 하면 됩니다. 또한 함수 호출은 왼쪽이 우선시 되므로 `(f 3) 4`와 `f 3 4`가 같습니다. (`f (3 4)`는 다릅니다!)

### 연산자

연산자는 '+-\*/%!=<>:,|&~$' 등의 문자로 이루어진 것을 말합니다. 연산자는 앞/뒤로 다른 표현식이 올 수 있으며, 괄호가 없는 경우에는 우선순위에 따라서 적당히 묶이게 됩니다. 우선순위는 연산자 제일 앞의 문자로 결정이 됩니다. (`+*`의 경우 '+'로 연산자가 결정되는 등) 연산자의 우선순위는 `*/%`, `+-`, `!=<>`, `&`, `|`, `:,`, `~`, `$` 순입니다. 또한 함수 호출이 모든 연산자 적용보다 우선적으로 적용됩니다. 예를 들어서 `f 3 + g 2 * 5`의 경우 `(f 3) + ((g 2) * 5)` 처럼 실행됩니다.

LFLC에서 연산자는 단항이나 이항이라고 정해져있지 않습니다. 그 연산이 어떻게 정의가 되었냐에 따라 다르죠. 예를 들어서 '+'는 `λr. λl. @add l r`과 같이 정의가 되어 있습니다. (LFLC에서는 연산자는 우변, 좌변 순으로 인자를 받습니다.) 만약 '+ 3'이라고 쓰게 되면 `(λr. λl. @add l r) 3` = `λl. @add l 3`이므로 인자 하나를 더 받아서 3과 더하는 함수가 반환됩니다. '!'의 경우는 `λx. @not x`처럼 정의가 되어 있어 '! 3'이라고 하면 3에 @not을 적용한 값이 바로 나오게 됩니다.

연산자 자체는 이름과 별개로 취급되기 때문에 `λ+. M` 같이 람다의 종속변수명에 연산자를 직접 넣는 것은 불가능합니다. 대신 `(+)`처럼 연산자 주변에 괄호를 치면 일반적인 이름과 같이 취급이 되기 때문에 `λ(+).M`처럼은 쓸 수 있습니다.

### 연산자 적용 함수

연산자 적용 함수는 `λx <- M; N` 과 같은 형태를 가지고 있습니다. 이 문법은 설탕에 불과한데, 실제로 실행될 때는 `M -> (λx. N)` 과 같이 실행이 됩니다. (이렇게 변형될 때는 연산자가 좌우로 반전이 됩니다. `+-`는 `-+`로, `<-<`는 `>->`로 바뀌는 등) 이런 모양이 왜 필요한지는 문제를 풀면서 알아가도록 하죠.

## LFLC 에디터

지금 화면의 오른쪽에 보이는 곳에 문제의 답을 적어서 제출을 하면 채점이 될 것입니다.

만약 `\`를 입력하려고 하면 에디터는 자동으로 `λ`로 바꿔줄 것이니 갑자기 이상한 글자가 나왔다고 놀라지는 마시길 :)

문제의 유형은 크게 2가지입니다.

* '...을 하는 프로그램을 작성하시오' 이 경우 소스코드를 그대로 실행을 하게 됩니다.
* '...을 하는 함수 XXX를 정의하시오' 이 경우에는 소스코드 위에 정의된 함수를 채점하게 됩니다. 예를 들어서 f를 정의하라고 하면 `\f := 함수; ...`과 같은 형식이기만 하면 알아서 채점이 될 것입니다. 추가로 함수를 몇개를 더 구현하는지는 별로 중요하지 않습니다.

## std

다음과 같은 것들은 보통 기본적으로 정의되어 있습니다. (일부 파트에서는 직접 구현하시라고 빠져있을 수도 있습니다.)

* `print x` 화면에 출력합니다. `@print`와 같습니다. 다만 LFLC는 게으른 평가를 하기 때문에 최종 값이 print가 아니면 화면에 출력되지 않을 수도 있습니다.
* `+`, `-`, `*`, `/`, `%` 타 언어의 사칙연산과 같습니다. `@addr`, `@subr`, `@mulr`, `@divr`, `@modr` 등으로 구현되며 `@...r`은 우변, 좌변 순으로 받는 builtin입니다.
* `==`, `!=`, `<=`, `>=`, `<`, `>` 등 비교 연산. 결과는 아래의 `true`나 `false`입니다. 마찬가지로 `@eqr`, `@ler, `@ltr`로 구현됩니다.
* `true`, `false` 처치 부호화가 된 진위형입니다. `if COND WHEN ELSE` 라는 if 함수로 사용할 수 있습니다. (COND에 조건, WHEN에 true일 때의 표현식, ELSE에 false일 때의 표현식이 들어갑니다.)
* `!`는 not, `&`, `|`는 각각 and, or 연산입니다.
* `F, S`라는 `,` 연산자로 F, S를 저장해두는 페어를 만들 수 있으며, `first PAIR`, `second PAIR`로 페어에 저장된 값을 가져올 수 있습니다.
* `nil`로 빈 리스트를, `VALUE : LIST`처럼 `:` 연산자로 VALUE를 LIST의 앞에 추가를 할 수 있습니다. 이렇게 만들어진 리스트는 `head LIST`, `tail LIST`로 가장 앞의 값이나 앞을 제외한 나머지 리스트를 가져올 수 있고 `isEmpty LIST`로 비어있는지 검사할 수 있습니다.
* `$`, `<|` 연산자. 좌변의 함수에 우변의 값을 넣습니다. 즉 `f $ x`, `f <| x`, `f x`는 모두 같습니다. 다만 연산자 `$`는 우선순위가 가장 낮기 때문에 `f (g x)`처럼 쓰는 것을 `f $ g x`처럼 괄호를 쓰지 않기 위해 대신 사용할 수도 있습니다.
* `=:`, `|>` 연산자. 우변의 함수에 좌변의 값을 넣습니다. 즉 `x =: f`, `x |> f`, `f x`는 모두 같습니다. 이 중 `=:`는 값을 이름에 바인드할 때 사용할 수 있습니다. 예를 들어서 `\\x := 10; x + 3` 처럼 말이죠.
* `**` 연산자. 두 함수를 합성할 때 쓰입니다. 예를 들어 `(f ** g) x`는 `f (g x)`와 같습니다.
* `S`, `K`, `I` 결합자.
* `U`, `Y`, `Z` 결합자.
